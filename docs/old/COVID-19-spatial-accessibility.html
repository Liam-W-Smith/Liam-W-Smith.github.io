<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Liam Smith - Spatial Accessibility of Healthcare Resources in Chicago</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #f2f2f2;
      }

      .quarto-title-block .quarto-title-banner {
        color: #f2f2f2;
background-image: url(../img/panorama5.jpg);
background-size: cover;
      }
</style>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Liam Smith</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Liam-W-Smith"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/liam-smith-b159791b3/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Spatial Accessibility of Healthcare Resources in Chicago</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In <em>Rapidly Measuring Spatial Accessibility of COVID-19 Healthcare Resources: A Case Study of Illinois, USA</em>, Kang et al.&nbsp;use the Enhanced Two-Step Floating Catchment Area (E2SFCA) method with parallel processing to assess the accessibility of ICU beds and ventilators to vulnerable populations – defined as individuals of 50 years of age or older – and COVID-19 patients in Illinois. The goal of their study was to provide policymakers with regularly updated information concerning the spatial capability of key treatment resources to COVID-19 patients and vulnerable populations. The authors found that access to ventilators and ICU beds was unevenly distributed throughout Illinois, and they published updated analyses daily in an online, interactive webpage called <a href="https://wherecovid19.cigi.illinois.edu/spatialAccess.html#7/40.000/-89.000/Dark_Mode-il_acc_i/370">WhereCovid</a>.</p>
<p>We seek to reproduce Kang et al.’s study for a few reasons. First, the global pandemic is a pressing issue, and public policy decisions regarding the pandemic ought to be based upon reputable research. Reproducing this study either confirms its findings, contributing to its validity as a basis for public policy, or overturns its findings, improving the basis of knowledge from which the government designs public policy. There are also intellectual and pedagogical motives for conducting a reproduction of this study. Intellectually, a reproduction confirms the validity of the researchers’ spatial techniques; and pedagogically, conducting a reproduction allows students to see how geospatial studies are conducted and encourages students think critically about their reputability.</p>
</section>
<section id="important-links" class="level2">
<h2 class="anchored" data-anchor-id="important-links">Important Links</h2>
<ul>
<li><p><a href="https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00229-x">Original publication</a></p></li>
<li><p><a href="https://github.com/cybergis/COVID-19AccessibilityNotebook">Original code repository</a></p></li>
<li><p><a href="https://github.com/Liam-W-Smith/RPr-Kang-2020">Reproduction repository</a></p></li>
</ul>
</section>
<section id="materials-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="materials-and-methods">Materials and Methods</h2>
<p>The Kang et al.&nbsp;study draws on four datasets: 1. A <strong>hospital dataset</strong> provided by the Illinois Department of Health, which contains information about the number of ICU beds and ventilators at each hospital. 2. A <strong>COVID-19 dataset</strong> also provided by the Illinois Department of Health, with information regarding the number of COVID-19 cases in each Zip Code in the state. 3. A <strong>residential dataset</strong> from the 2018 American Community Survey 5 year table detailing the population and demographic composition of each tract in Illinois. 4. A <strong>road network dataset</strong> queried from OpenStreetMap using the Python package, OSMnx.</p>
<p>The provided research notebook includes only the data for the City of Chicago, because it is computationally burdensome for users to conduct this reproduction on the entire state of Illinois. In order to deal with boundary issues (i.e.&nbsp;sometimes the fastest route to a hospital in Chicago uses streets outside the city), a past GEOG 323 class revised the original methodology, extending the road network 15 miles past the boundaries of Chicago. However, the population data provided by the authors contained information exclusively for the tracts within Chicago. Residents of the Chicago suburbs can, and likely do, take advantage of the services provided by the hospitals physically within the city. For this reason, we know that a more accurate analysis would incorporate population information of Chicago’s suburbs.</p>
<p>In our class’s reproduction of this analysis, we seek to remedy this issue by extending the pool of demographic information to include the tracts in all of the counties neighboring Cook county, which is the county where Chicago is located. We did not address the geographic extent of the COVID-19 case data.</p>
<p>The computational resources available for the original study and our reproduction included a CyberGIS server and the programming language Python. Specifically, the study was conducted in a Jupyter notebook using the virtual computing environment, CyberGISX, a cyberinfrastructure project which performs computations on a bank of supercomputers at the University of Illinois Urbana-Champaign. Required Python packages include numpy, pandas, geopandas, networkx, OSMnx, shapely, matplotlib, tqdm, and multiprocessing.</p>
</section>
<section id="our-additions-to-the-code" class="level2">
<h2 class="anchored" data-anchor-id="our-additions-to-the-code">Our Additions to the Code</h2>
<p>To address our concern that individuals who live outside of Chicago might also use the hospital services within Chicago, we reconfigured the pre-processing of residential data in order to include households in the suburbs. Once we adjusted the input data, we simply re-ran the analysis to generate new results. Since the road network in the Jupyter notebook already included roads within a 15 mile buffer, we knew that the network analysis would work with our new residential dataset. Furthermore, since the code joins the centroids of census tracts that intersect catchment areas, we know that including superfluous residential information in our input dataset will not bring superfluous residential information into our results; residences that are located outside of the catchment areas simply are not counted. For this reason, we extended the pool of demographic information drastically, such that it includes the tracts in all of the counties neighboring Cook county.</p>
<p>Our additions to the code can be found in <a href="https://github.com/Liam-W-Smith/RPr-Kang-2020/blob/main/procedure/code/04-Class-Reanalysis.ipynb">/procedure/code/04-Class-Reanalysis.ipynp</a> under the “Population and COVID-19 Cases Data by County” subheading and our new figures are under <a href="https://github.com/Liam-W-Smith/RPr-Kang-2020/tree/main/results/figures/reproduction">/results/figures/reproduction</a> and are copied below for convenience:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data for tract geometry</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>tract_geom <span class="op">=</span> gpd.read_file(<span class="st">'./data/raw/public/ReanalysisClass/cb_2018_17_tract_500k.shp'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>tract_geom.head()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Load data for Census Demographics</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>tract_dem <span class="op">=</span> pd.read_csv(<span class="st">'./data/raw/public/ReanalysisClass/real_data_census_illinois.csv'</span>, sep<span class="op">=</span><span class="st">","</span>, skiprows <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>tract_dem.head()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the following columns: S0101_C01_001E, S0101_C01_012E, S0101_C01_013E, S0101_C01_014E, S0101_C01_015E, S0101_C01_016E, S0101_C01_017E, S0101_C01_018E, S0101_C01_019E</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>at_risk_csv <span class="op">=</span> tract_dem[[<span class="st">"GEO_ID"</span>, <span class="st">"NAME"</span>, <span class="st">"B01001_001E"</span>, <span class="st">"B01001_016E"</span>, <span class="st">"B01001_017E"</span>, <span class="st">"B01001_018E"</span>, <span class="st">"B01001_019E"</span>, <span class="st">"B01001_020E"</span>, <span class="st">"B01001_021E"</span>, <span class="st">"B01001_022E"</span>, <span class="st">"B01001_023E"</span>, <span class="st">"B01001_024E"</span>, <span class="st">"B01001_025E"</span>, <span class="st">"B01001_040E"</span>, <span class="st">"B01001_041E"</span>, <span class="st">"B01001_042E"</span>, <span class="st">"B01001_043E"</span>, <span class="st">"B01001_044E"</span>]]</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#Note: after a certain number of column names, atom becomes convinced that you're done with your code chunk. For this reason, I left out the last few columns in the code above, but they ought to be included when running the code.</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the number of columns in dataframe</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">len</span>(at_risk_csv.columns)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Sum all of the counts for individuals who are 50 years or older</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>at_risk_csv[<span class="st">'OverFifty'</span>] <span class="op">=</span> at_risk_csv.iloc[:, <span class="dv">3</span>:<span class="dv">23</span>].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="dv">1</span>)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># create new pop column with a more useful name</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>at_risk_csv[<span class="st">'TotalPop'</span>] <span class="op">=</span> at_risk_csv[<span class="st">'B01001_001E'</span>]</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># drop columns to clean the data set</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>at_risk_csv <span class="op">=</span> at_risk_csv.drop(at_risk_csv.columns[<span class="dv">2</span>:<span class="dv">23</span>], axis <span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># rename col to join</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>newnames <span class="op">=</span> {<span class="st">"GEO_ID"</span>:<span class="st">"AFFGEOID"</span>}</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>at_risk_csv <span class="op">=</span> at_risk_csv.rename(columns <span class="op">=</span> newnames)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># check projection</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tract_geom.crs)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="co"># transform CRS</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>tract_geom <span class="op">=</span> tract_geom.to_crs(epsg<span class="op">=</span><span class="dv">4326</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># check projection</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(tract_geom.crs)</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co"># select tracts in Cook County and in counties adjacent to Cook County</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>tract_geom <span class="op">=</span> tract_geom.loc[(tract_geom[<span class="st">"COUNTYFP"</span>] <span class="op">==</span> <span class="st">'031'</span>)<span class="op">|</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>                            (tract_geom[<span class="st">"COUNTYFP"</span>] <span class="op">==</span> <span class="st">'089'</span>)<span class="op">|</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                            (tract_geom[<span class="st">"COUNTYFP"</span>] <span class="op">==</span> <span class="st">'197'</span>)<span class="op">|</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                            (tract_geom[<span class="st">"COUNTYFP"</span>] <span class="op">==</span> <span class="st">'043'</span>)<span class="op">|</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>                            (tract_geom[<span class="st">"COUNTYFP"</span>] <span class="op">==</span> <span class="st">'097'</span>)<span class="op">|</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>                            (tract_geom[<span class="st">"COUNTYFP"</span>] <span class="op">==</span> <span class="st">'111'</span>)]</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="co"># perform an inner join based on AFFGEOID columns</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>atrisk_data <span class="op">=</span> tract_geom.merge(at_risk_csv, how<span class="op">=</span><span class="st">'inner'</span>, on<span class="op">=</span><span class="st">'AFFGEOID'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="results-and-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h2>
<p>Upon running the code with our updated residential dataset, we generated new figures, some of which differ significantly from the original results. Since we did not address the spatial extent of the COVID-19 case data, I am excluding COVID-19 accessibility maps from this report. The following maps reveal the accessibility of ICU beds and ventilators to vulnerable populations in Chicago. Darker blue represents higher spatial accessibility and lighter blue represents lower spatial accessibility.</p>
<section id="accessibility-of-icu-beds-to-vulnerable-populations" class="level3">
<h3 class="anchored" data-anchor-id="accessibility-of-icu-beds-to-vulnerable-populations">Accessibility of ICU Beds to Vulnerable Populations</h3>
<section id="original-figure-after-revisions-by-geog-323-spring-2021" class="level4">
<h4 class="anchored" data-anchor-id="original-figure-after-revisions-by-geog-323-spring-2021">Original Figure (after revisions by GEOG 323 Spring 2021)</h4>
<p><img src="assets/Kang_OG_Reproduction/pop_icu_class.png" class="img-fluid" alt="Accessibility of ICU Beds to Vulnerable Populations, original figure"> #### Updated Figure <img src="assets/Kang_Class_Reproduction/pop_icu_class.png" class="img-fluid" alt="Accessibility of ICU Beds to Vulnerable Populations, updated figure"> Note that the extents of the darker blues are much smaller in the updated figure, especially in the northwest and southwest. The new figure also includes a section of light blue in the northwest, which was a darker shade in the original figure. We will discuss these results further after reviewing the second set of figures.</p>
</section>
</section>
<section id="accessibility-of-ventilators-to-vulnerable-populations" class="level3">
<h3 class="anchored" data-anchor-id="accessibility-of-ventilators-to-vulnerable-populations">Accessibility of Ventilators to Vulnerable Populations</h3>
<section id="original-figure-after-revisions-by-geog-323-spring-2021-1" class="level4">
<h4 class="anchored" data-anchor-id="original-figure-after-revisions-by-geog-323-spring-2021-1">Original Figure (after revisions by GEOG 323 Spring 2021)</h4>
<p><img src="assets/Kang_OG_Reproduction/pop_vents_class.png" class="img-fluid" alt="Accessibility of Ventilators to Vulnerable Populations, original figure"> #### Updated Figure <img src="assets/Kang_Class_Reproduction/pop_vents_class.png" class="img-fluid" alt="Accessibility of Ventilators to Vulnerable Populations, updated figure"> Similar to the first set of figures, the extents of the darker blues are smaller in the updated figure than in the original figure, especially in the northwest and southwest. The new figure also includes a section of light blue in the northwest, where the original figure had been darker.</p>
<p>For both ICU beds and ventilators, the original and updated figures are similar on the east side, but differ significantly in the northwest and southwest. These differences makes sense. Because Chicago borders Lake Michigan on the east and it takes time to drive to hospitals, including adjacent counties in the residential dataset will not increase the population accessing hospitals in Chicago’s east side. With a similar number of people accessing hospital services, the spatial accessibility of those services remains similar for individuals who live in eastern Chicago. However, our adjusted residential dataset does impact the accessibility of hospitals for residents in western, northern, and southern Chicago. The hospitals in these parts of Chicago are less isolated from suburban residents, as they can drive to these hospitals in less time. Incorporating those suburban residents into our analysis increases the perceived demand for hospital services in western, northern, and southern Chicago. With more people accessing hospital services, it is more difficult for any one individual to access those services, and the spatial accessibility measure mapped by our figures declines accordingly.</p>
<p>The differences between the original and updated figures highlight the inaccuracies that boundary effects introduce to Kang et al’s results. In their paper, Kang et al include hospitals within 15 miles of the city, but not the residents. Since residents outside of the city also use hospitals within the city, the authors appear to have neglected an important boundary effect. Our updated analysis accounts for this issue and illustrates that the surrounding populations significantly impact the spatial accessibility of healthcare resources within the city.</p>
<p>If you would like more information regarding the processes and results of this reproduction, please see my complete reproduction repository <a href="https://github.com/Liam-W-Smith/RPr-Kang-2020">here</a>.</p>
</section>
</section>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>At the end of the day, we were able to reproduce the study and make minor improvements to the code. This would not have been possible for a group of undergraduate students to accomplish in a couple of afternoons had we not been provided the Jupyter notebook on CyberGISX. The Jupyter notebook illustrates exactly how the authors addressed their research questions and provides some information as to the motivations for their choices, making it possible to review their code and methodology in a manner that is impossible for most research papers. Cudos to the authors for their foresight in publishing their work in a cutting-edge, reproducible environment.</p>
<p>Conducting the reproduction, however, also introduced me to the limitations and errors in their work. Discovering that their analysis of Chicago included hospitals but neglected the road networks and population outside of the city was surprising and somewhat eye-opening. The authors of the study are some of our top geospatial researchers, and they still made mistakes. If anything, this reproduction drew my attention to the importance of reproducing academic studies. All of us, even those at the top of the field, make mistakes, and a thorough peer review process is critical to addressing those errors.</p>
<p>Another key takeaway is that undocumented pre-processing of data poses significant barriers to reproducibility. While the authors performed some manipulations on their data simply to format it for the study, they do not document those manipulations in their code. For this reason, when we extended the geographic extent of the residential database, we had no model to work off of and had to develop our own method.</p>
<p>Overall, Kang et al’s study on spatial accessibility of COVID-19 healthcare resources is reproducible, and their Jupyter notebook on CyberGISX provides the public with all of the information necessary to computationally reproduce their analysis in Chicago. There are, however, a couple areas in which the work could be improved. Future work on the notebook could include documenting their data preprocessing and adding more comments to their code to make it easier to assess their methodology. Additionally, to account for the fact that residents outside of Chicago (which we added in this revision) could also access the hospitals outside of the city that are included in this analysis, the road network ought to be extended even further. Since hospital catchment areas are 30 minutes of driving time, extending the road network 60 miles past the boundary of Chicago would be adequate. Further than that distance, even an individual traveling at the maximum speed limit in a straight line would not be included in any catchment areas, so they would be irrelevant to our analysis. This Jupyter notebook is already an incredibly valuable tool for teaching and learning the methods of reproducible GIS, and continual work on the notebook will only continue to improve its functionality.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>