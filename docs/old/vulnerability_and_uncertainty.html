<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Liam Smith - Understanding Uncertainty in Vulnerability Indices</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #f2f2f2;
      }

      .quarto-title-block .quarto-title-banner {
        color: #f2f2f2;
background-image: url(../img/panorama5.jpg);
background-size: cover;
      }
</style>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Liam Smith</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Liam-W-Smith"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/liam-smith-b159791b3/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Understanding Uncertainty in Vulnerability Indices</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>A vulnerability index is a measure of the risk that some hazard poses to different areas. These indices consider and weight a number of factors based on how significantly they impact a region’s susceptibility to that hazard. In <em>Uncertainty Analysis for a Social Vulnerability Index</em>, Eric Tate articulates a framework for designing and evaluating vulnerability indices, and in <em>Vulnerability modeling for sub-Saharan Africa: An operationalized approach in Malawi</em>, Malcomb et al present an index assessing the vulnerability of different parts of Malawi to climate change.</p>
<p>In class, we reproduced Malcomb et al’s study using a reproducible research compendium provided by Professor Holler. My repository for the reproduction can be found <a href="https://github.com/Liam-W-Smith/RPr-Malcomb-2014/tree/main/data">here</a> and our reproduced figures are shown below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/malcomb-figures.png" class="img-fluid figure-img"></p>
<figcaption>Reproduced Figures</figcaption>
</figure>
</div>
<p>In this post, I seek to critique Malcomb et al’s work in the context of Tate’s framework. According to Tate, the construction of a vulnerability index includes a series of 9 steps, which are conducted in the order indicated by the flowchart below. In what follows, I will describe each stage of the process individually and point out areas where Malcomb et al could improve their work.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/Index_construction_flowchart.png" class="img-fluid figure-img"></p>
<figcaption>Figure 1 from Tate’s paper</figcaption>
</figure>
</div>
<p><strong>Model structure:</strong> this is the first stage of the process, in which the index developer decides whether to follow a <em>deductive</em>, <em>hierarchical</em>, or <em>inductive</em> design. <em>Deductive</em> designs are based on theory and typically include 10 or fewer normalized variables. <em>Hierarchical</em> designs are similar; they typically include a greater number of indicators, which are also chosen based on theory, and which are grouped into subindices. Both deductive and hierarchical models depend on expert opinion and critical thought, so there is no internal proof of validity. <em>Inductive</em> designs are more robust, using data and statistical/regression analysis to decide which variables are more indicative of the outcome of interest. Malcomb et al opt for a hierarchical design of 18 variables organized into three subindices as outlined below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="assets/Malcomb_Model_Structure.png" class="img-fluid figure-img"></p>
<figcaption>Malcomb et al’s Model Structure</figcaption>
</figure>
</div>
<p><strong>Indicator set:</strong> the way in which one selects their indicators greatly impacts the validity of their vulnerability index, as certain methods are more likely to introduce bias and error than others. <em>Deductive</em> methods select indicators based on theory; <em>normative</em> methods rely on value judgements and expert opinion; <em>inductive</em> methods rely on data and statistical analysis of real-world results; <em>non-substantial</em> methods rely on the characteristics of data alone; and <em>practical</em> methods select indicators based on what one can access and afford.</p>
<p>Malcomb et al rely heavily on the normative method, conducting an extensive process of interviews with locals in Malawi. In their paper, they also cite a number of studies on the validity of their indicators, which leads me to believe that they cross-checked the feedback from Malawians with academic work on the issue. On one hand it makes sense to hear from locals and experts about the factors influencing their day-to-day lives, but on the other hand, the normative method inherently introduces bias into their model. A more robust method would involve some statistical analysis of their indicators. Malcomb et al also take advantage of the practical method, because data with sufficient spatial granularity is seldom found in Sub-Saharan Africa. For example, the authors use a global dataset from UNEP/GRID on flood and drought risk in Malawi, in which the rasters are given in a global Coordinate Reference System with large cell sizes. A more substantial search for indicators might have considered methods to create more granular rasters.</p>
<p><strong>Analysis scale:</strong> this step occurs simultaneously with the previous step, and refers to the selection of an appropriate geographic scale for the analysis. For one map, Malcomb et al select an analysis level of Traditional Authority, a level of government responsible for some degree of resilience planning and disaster relief. While it makes sense to conduct a vulnerability analysis at the appropriate government subdivision, the methodology employed to transform the data to the Traditional Authority level introduces substantial error. DHS household data is given at a so-called “cluster” level, where households corresponding to a certain cluster are located within 5 km of the point representing that cluster. Data is spatially aggregated from the cluster level to the Traditional Authority level, but since households are within 5 km of the clusters, they are not all actually within the Traditional Authorities that the clusters aggregate into.</p>
<p>For another set of maps, Malcomb et al rasterize all of their layers to the cell size of the smallest raster. This process, in which the authors use more general data to generate more specific data, introduces substantial uncertainty, because it assumes that every subsection of a given cell is identical. Fundamentally, one cannot go from simplified data to more complex data without ignoring critical nuances of reality.</p>
<p><strong>Measurement error:</strong> as discussed in my previous blog post, <a href="error-and-uncertainty">Error and Uncertainty</a>, measurement error propogates through one’s analysis. There are numerous examples of measurement error in this study, but for the sake of time I will address just one of them. One gaping measurement error in Malcomb et al’s analysis stems from the “Exposition to Drought Events” indicator, which the authors assume represents the likelihood that an area will be affected by drought. Upon reviewing the metadata for that raster, it becomes apparent that the layer is not a measure of a region’s exposition to drought, but rather an estimation of the population in each grid that is exposed to drought annually. Using population-based drought data is a flawed approach, because it exaggerates the perceived drought risk for cities and reduces the perceived drought risk for rural areas.</p>
<p><strong>Transformation:</strong> after measuring data, one must decide how to transform their data to be suitable for analysis. Generally speaking, it is best practice to represent vulnerability with relative proportions of individuals at risk rather than total populations, because simple counts exaggerate the vulnerability for urban areas. Unfortunately, Malcomb et al fail to transform a number of their indicators before applying their weighted sum. For example, they consider the number of orphans in each household, when it might be more meaningful to consider the proportion of individuals in each household who are orphans.</p>
<p><strong>Normalization:</strong> In order to adjust for the fact that different variables have different units and scales, one must normalize their indicators onto a common scale before considering them together. One popular method of scaling is called linear scaling, which uses the following formula to assign every observation a value between 0 and 1: (observation - min)/(max - min). Another method of scaling uses the z-score, calculated as (observation - mean)/(standard deviation). Additionally, some indicators in a vulnerability index may exhibit a trend that represents the opposite of vulnerability; that is, when the value of that indicator increases, the vulnerability of an area decreases. Indicators like this ought to undergo a directionality adjustment before normalization. Directionality adjustments typically involve multiplying by -1 or taking the reciprocal of each value.</p>
<p>In their study, Malcomb et al apply linear scaling to each of their indicators, which works just fine for their quantitative variables. However, some of their indicators (sex of household head, the type of cooking fuel, the urban/rural setting, etc) are not quantitative. How does one take a categorical or binary variable and convert it onto a scale from 0 to 5? It does not make sense to transform a simpler class of data into a more complex one, and it is not clear how the authors accomplished that. Malcomb et al also provide no information about directionality adjustments, leaving their work irreproducible and slightly ambiguous.</p>
<p><strong>Weighting:</strong> perhaps the most subjective decision when designing a vulnerability index is how one selects which weights to apply to each indicator. Malcomb et al again apply a normative strategy for selecting weights, relying on interviews with Malawians to determine which factors most greatly impact one’s vulnerability to climate change. It is difficult to assess the validity of their weighting without having conducted the interviews in Malawi myself (the authors do not provide any of the interview content), but I would feel more comfortable with their weights had the authors employed some statistical analysis during the selection process.</p>
<p><strong>Aggregation:</strong> this stage refers to the method one uses to combine all of their indicators into a single index. The most common method of aggregation, and the method employed by Malcomb et al, is known as <em>additive aggregation</em>, which is implemented as a weighted sum of the indicators. Additive aggregation considers each indicator invidually, ignoring any interaction between indicators, and it is considered a substitutable method, because an especially high value of one indicator can mask low values of other indicators. Other methods of aggregation account better for interaction effects and substitution, but it is unclear whether the authors of the paper considered these methods during their work.</p>
<p><strong>Uncertainty and sensitivity analysis validation:</strong> in the final step of index construction, one identifies and reduces uncertainty in the model’s assumptions. Unfortunately, this step is often neglected in vulnerability analyses, as it is in Malcomb et al’s work. This blog post qualitatively identifies several sources of error and uncertainty, which the authors could consider in an evaluation of their methodology. A more formal uncertainty and sensitivity analysis ought to employ mathematical methods like Monte Carlo simulations to assess the validity of their index.</p>
<p>This brings us to the conclusion of the index construction process. Inspecting each step individually has revealed numerous ways in which a vulnerability model is subject to uncertainty, and evaluating Malcomb et al’s work in the context of this framework has illustrated a number of shortcomings of their work. In conclusion, index developers ought to think critically about uncertainty as they craft their models and take time to validate their model after the fact.</p>
<p><strong>References:</strong></p>
<ul>
<li><p>Malcomb, D. W., Weaver, E. A., &amp; Krakowka, A. R. (2014). Vulnerability modeling for sub-Saharan Africa: An operationalized approach in Malawi. Applied Geography, 48, 17–30. <a href="https://doi.org/10.1016/j.apgeog.2014.01.004">https://doi.org/10.1016/j.apgeog.2014.01.004</a></p></li>
<li><p>Tate, E. (2013). Uncertainty Analysis for a Social Vulnerability Index. Annals of the Association of American Geographers, 103(3), 526–543. <a href="https://doi.org/10.1080/00045608.2012.700616">https://doi.org/10.1080/00045608.2012.700616</a></p></li>
<li><p>Hinkel, J. (2011). “Indicators of vulnerability and adaptive capacity”: Towards a clarification of the science–policy interface. Global Environmental Change, 21(1), 198–208. <a href="https://doi.org/10.1016/j.gloenvcha.2010.08.002">https://doi.org/10.1016/j.gloenvcha.2010.08.002</a></p></li>
<li><p><a href="assets/drought_physical_exposure copy.pdf">Metadata for Drought Risk Raster</a></p></li>
</ul>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>